'use strict';

/* eslint-disable no-empty-function, no-process-env */
var request = require('@sanity/request'); // `request` in node, `xhr` in browsers
var queryString = require('./queryString');
var Observable = require('zen-observable');

var debug = (process.env.DEBUG || '').indexOf('sanity') !== -1;

var log = function log() {};
if (process.env.NODE_ENV !== 'production') {
  log = require('debug')('sanity:client');
}

module.exports = function httpRequest(options) {
  if (options.query) {
    options.uri += '?' + queryString.stringify(options.query);
  }

  if (debug) {
    log('HTTP %s %s', options.method || 'GET', options.uri);
    if (options.method === 'POST' && options.body) {
      log('Request body: %s', JSON.stringify(options.body, null, 2));
    }
  }

  var observable = new Observable(function (observer) {
    var req = request(options, function (err, res, body) {
      if (err) {
        observer.error(err);
        return;
      }

      log('Response code: %s', res.statusCode);
      if (debug && body) {
        log('Response body: %s', stringifyBody(body, res));
      }

      var isHttpError = res.statusCode >= 400;

      if (isHttpError && body) {
        var msg = (body.errors ? body.errors.map(function (error) {
          return error.message;
        }) : []).concat([body.error, body.message]).filter(Boolean).join('\n');

        var error = new Error(msg || httpError(res));
        error.responseBody = stringifyBody(body, res);
        error.statusCode = res.statusCode;
        observer.error(error);
        return;
      } else if (isHttpError) {
        var httpErr = new Error(httpError(res));
        httpErr.statusCode = res.statusCode;
        observer.error(httpErr);
        return;
      }

      observer.next({ type: 'response', body: body });
      observer.complete();
    });

    // Todo: shim over node/browser differences
    if ('upload' in req && 'onprogress' in req.upload) {
      req.upload.onprogress = handleProgress('upload');
    }

    if ('onprogress' in req) {
      req.onprogress = handleProgress('download');
    }

    req.onabort = function () {
      observer.next({ type: 'abort' });
      observer.complete();
    };

    return function () {
      return req.abort();
    };

    function handleProgress(stage) {
      return function (event) {
        var percent = event.lengthComputable ? event.loaded / event.total : -1;
        observer.next({
          type: 'progress',
          stage: stage,
          percent: percent
        });
      };
    }
  });

  observable.toPromise = function () {
    var last = void 0;
    return observable.forEach(function (value) {
      last = value;
    }).then(function () {
      return last.body;
    });
  };
  return observable;
};

function httpError(res) {
  return 'Server responded with HTTP ' + res.statusCode + ' ' + (res.statusMessage || '') + ', no description';
}

function stringifyBody(body, res) {
  var contentType = (res.headers['content-type'] || '').toLowerCase();
  var isJson = contentType.indexOf('application/json') !== -1;
  return isJson ? JSON.stringify(body, null, 2) : body;
}
//# sourceMappingURL=request.js.map