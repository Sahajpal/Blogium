'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assign = require('xtend/mutable');
var validators = require('../validators');
var Patch = require('./patch');

var defaultMutateOptions = { returnDocuments: false };

function Transaction() {
  var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var client = arguments[1];

  this.operations = operations;
  this.client = client;
}

assign(Transaction.prototype, {
  clone: function clone() {
    var addMutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    return new Transaction(this.operations.concat(addMutations), this.client);
  },
  create: function create(doc) {
    return this._create(doc, 'create');
  },
  createIfNotExists: function createIfNotExists(doc) {
    return this._create(doc, 'createIfNotExists');
  },
  createOrReplace: function createOrReplace(doc) {
    return this._create(doc, 'createOrReplace');
  },
  delete: function _delete(documentId) {
    validators.validateDocumentId('delete', documentId);
    return this._add({ delete: { id: documentId } });
  },
  patch: function patch(documentId, patchOps) {
    var isBuilder = typeof patchOps === 'function';
    var isPatch = documentId instanceof Patch;

    // transaction.patch(client.patch('documentId').inc({visits: 1}))
    if (isPatch) {
      return this._add({ patch: documentId.serialize() });
    }

    // patch => patch.inc({visits: 1}).set({foo: 'bar'})
    if (isBuilder) {
      var patch = patchOps(new Patch(documentId, {}, this.client));
      if (!(patch instanceof Patch)) {
        throw new Error('function passed to `patch()` must return the patch');
      }

      return this._add({ patch: patch.serialize() });
    }

    return this._add({ patch: assign({ id: documentId }, patchOps) });
  },
  serialize: function serialize() {
    return this.operations.slice();
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit(options) {
    if (!this.client) {
      throw new Error('No `client` passed to transaction, either provide one or pass the ' + 'transaction to a clients `mutate()` method');
    }

    return this.client.mutate(this.serialize(), options || defaultMutateOptions);
  },
  reset: function reset() {
    this.operations = [];
    return this;
  },
  _create: function _create(doc, op) {
    if (!doc._id && !this.client) {
      throw new Error('Document needs an _id property when transaction is create outside a client scope. ' + 'Pass `{_id: "<datasetName>:"}` to have Sanity generate an ID for you.');
    }

    validators.validateObject(op, doc);
    var dataset = validators.hasDataset(this.client.clientConfig);
    var mutation = _defineProperty({}, op, assign({}, doc, { _id: doc._id || dataset + '/' }));
    return this._add(mutation);
  },
  _add: function _add(mut) {
    return this.clone(mut);
  }
});

module.exports = Transaction;
//# sourceMappingURL=transaction.js.map