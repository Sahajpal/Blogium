'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assign = require('xtend/mutable');
var validators = require('../validators');
var encodeQueryString = require('./encodeQueryString');
var Transaction = require('./transaction');
var Patch = require('./patch');

var getMutationQuery = function getMutationQuery(options) {
  return assign(
  // Always return IDs
  { returnIDs: true },

  // Allow user to disable returning documents
  options.returnDocuments === false ? {} : { returnDocuments: true });
};

var getQuerySizeLimit = 1948;

module.exports = {
  fetch: function fetch(query, params) {
    return this.dataRequest('query', { query: query, params: params }).then(function (res) {
      return res.result || [];
    });
  },
  getDocument: function getDocument(id) {
    return this.request({
      uri: '/data/doc/' + id,
      json: true
    }).then(function (res) {
      return res.documents && res.documents[0];
    });
  },
  create: function create(doc, options) {
    return this._create(doc, 'create', options);
  },
  createIfNotExists: function createIfNotExists(doc, options) {
    return this._create(doc, 'createIfNotExists', options);
  },
  createOrReplace: function createOrReplace(doc, options) {
    return this._create(doc, 'createOrReplace', options);
  },
  patch: function patch(selector, operations) {
    return new Patch(selector, operations, this);
  },
  delete: function _delete(documentId) {
    validators.validateDocumentId('delete', documentId);
    return this.dataRequest('mutate', { mutations: [{ delete: { id: documentId } }] });
  },
  mutate: function mutate(mutations, options) {
    var mut = mutations instanceof Patch ? mutations.serialize() : mutations;
    var muts = Array.isArray(mut) ? mut : [mut];

    return this.dataRequest('mutate', { mutations: muts }, options);
  },
  transaction: function transaction(operations) {
    return new Transaction(operations, this);
  },
  dataRequest: function dataRequest(endpoint, body) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var isMutation = endpoint === 'mutate';

    // Check if the query string is within a configured threshold,
    // in which case we can use GET. Otherwise, use POST.
    var strQuery = !isMutation && encodeQueryString(body);
    var useGet = !isMutation && strQuery.length < getQuerySizeLimit;
    var stringQuery = useGet ? strQuery : '';
    var returnFirst = options.returnFirst;

    return validators.promise.hasDataset(this.clientConfig).then(function (dataset) {
      return _this.request({
        method: useGet ? 'GET' : 'POST',
        uri: '/data/' + endpoint + '/' + dataset + stringQuery,
        json: true,
        body: useGet ? undefined : body,
        query: isMutation && getMutationQuery(options)
      });
    }).then(function (res) {
      if (!isMutation) {
        return res;
      }

      var results = res.results || [];
      if (options.returnDocuments) {
        return returnFirst ? results[0] && results[0].document : results.map(function (mut) {
          return mut.document;
        });
      }

      // Only return IDs
      var key = returnFirst ? 'documentId' : 'documentIds';
      var ids = returnFirst ? results[0] && results[0].id : results.map(function (mut) {
        return mut.id;
      });
      return _defineProperty({ transactionId: res.transactionID }, key, ids);
    });
  },
  _create: function _create(doc, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var dataset = validators.hasDataset(this.clientConfig);
    var mutation = _defineProperty({}, op, assign({}, doc, { _id: doc._id || dataset + '/' }));
    var opts = assign({ returnFirst: true, returnDocuments: true }, options);
    return this.dataRequest('mutate', { mutations: [mutation] }, opts);
  }
};
//# sourceMappingURL=dataMethods.js.map