'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var deepAssign = require('deep-assign');
var assign = require('xtend/mutable');
var validateObject = require('../validators').validateObject;

function Patch(selection) {
  var operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var client = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  this.selection = selection;
  this.operations = assign({}, operations);
  this.client = client;
}

assign(Patch.prototype, {
  clone: function clone() {
    var addOps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return new Patch(this.selection, assign({}, this.operations, addOps), this.client);
  },
  merge: function merge(props) {
    validateObject('merge', props);
    return this.clone({ merge: deepAssign(this.operations.merge || {}, props) });
  },
  set: function set(props) {
    return this._assign('set', props);
  },
  setIfMissing: function setIfMissing(props) {
    return this._assign('setIfMissing', props);
  },
  replace: function replace(props) {
    validateObject('replace', props);
    return this.clone({ replace: props });
  },
  inc: function inc(props) {
    return this._assign('inc', props);
  },
  dec: function dec(props) {
    return this._assign('dec', props);
  },


  // @todo implement when in gradient
  unset: function unset(props) {
    throw new Error('Not implemented yet');
  },


  // @todo implement when in gradient
  append: function append(props) {
    throw new Error('Not implemented yet');
  },


  // @todo implement when in gradient
  prepend: function prepend(props) {
    throw new Error('Not implemented yet');
  },


  // @todo implement when in gradient
  splice: function splice(props) {
    throw new Error('Not implemented yet');
  },
  serialize: function serialize() {
    return assign(getSelection(this.selection), this.operations);
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!this.client) {
      throw new Error('No `client` passed to patch, either provide one or pass the ' + 'patch to a clients `mutate()` method');
    }

    var returnFirst = typeof this.selection === 'string';
    var opts = assign({ returnFirst: returnFirst, returnDocuments: true }, options);
    return this.client.mutate({ patch: this.serialize() }, opts);
  },
  reset: function reset() {
    return new Patch(this.selection, {}, this.client);
  },
  _assign: function _assign(op, props) {
    validateObject(op, props);
    return this.clone(_defineProperty({}, op, assign({}, this.operations[op] || {}, props)));
  }
});

function getSelection(sel) {
  if (typeof sel === 'string' || Array.isArray(sel)) {
    return { id: sel };
  }

  if (sel && sel.query) {
    return { query: sel.query };
  }

  var selectionOpts = ['* Dataset-prefixed document ID (<dataset/docId>)', '* Array of dataset-prefixed document IDs', '* Object containing `query`'].join('\n');

  throw new Error('Unknown selection for patch - must be one of:\n\n' + selectionOpts);
}

module.exports = Patch;
//# sourceMappingURL=patch.js.map